var data=[{"collection_id":"1540787832620","create_time":"2018-11-02","description":"内部类；error和exception类；数据库管理系统(Database Management System)；HashMap和Hashtable；","id":"1541130088761","title":"练习错误5","collection_name":"牛客网"},{"collection_id":"1540281721933","create_time":"2018-11-02","description":"1.乐观锁与悲观锁\n2.cas\n3.互斥同步和非阻塞同步\n4.适应性自旋（Adaptive  Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向\n锁（Biased Locking）","id":"1541148723250","title":"关于锁的一些问题和回答","collection_name":"技术"},{"collection_id":"1540281721933","create_time":"2018-11-02","description":"如果对什么是线程、什么是进程仍存有疑惑，请先Google之，因为这两个概念不在本文的范围之内。\n\n用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应\u201c多角色\u201d的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的\u201c生产者，消费者模型\u201d。\n\n很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。","id":"1541152391354","title":"多线程-转","collection_name":"技术"},{"collection_id":"1540281721933","create_time":"2018-11-02","description":"在运用CAS做Lock-Free操作中有一个经典的ABA问题：\n\n线程1准备用CAS将变量的值由A替换为B，在此之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。但实际上这时的现场已经和最初不同了，尽管CAS成功，但可能存在潜藏的问题，例如下面的例子：","id":"1541152463306","title":"用AtomicStampedReference解决ABA问题-转","collection_name":"技术"},{"collection_id":"1540787832620","create_time":"2018-11-01","description":"关于final关键字和类型转换；java重载，重载只要求参数列表不同，返回值无关；匿名内部类；short转byte；Java中类是单继承，但接口可以多继承，Interfere1 extends Interface2,Interface3","id":"1541063522900","title":"练习错误4","collection_name":"牛客网"},{"collection_id":"1540787832620","create_time":"2018-10-29","description":"集合的框架","id":"1540795592451","title":"练习错误1","collection_name":"牛客网"},{"collection_id":"1540281721933","create_time":"2018-10-29","description":"堆内存设置，原理，JVM堆内存分为2块：Permanent Space 和 Heap Space。\nPermanent 即 持久代（Permanent Generation），主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大。\nHeap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。","id":"1540796578135","title":"JVM 堆内存设置原理","collection_name":"技术"},{"collection_id":"1540281721933","create_time":"2018-10-29","description":"堆区:1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 ；栈区:1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。","id":"1540797684016","title":"java内存说明","collection_name":"技术"},{"collection_id":"1540787832620","create_time":"2018-10-29","description":"类的初始化过程，public private protected default作用域 ；关于抽象类与最终类与接口；throw和throws的区别","id":"1540798472160","title":"练习错误2","collection_name":"牛客网"},{"collection_id":"1540787832620","create_time":"2018-10-29","description":"局部内部类可以用哪些修饰符修饰；full GC触发的条件；java程序","id":"1540800799422","title":"练习错误3","collection_name":"牛客网"},{"collection_id":"1540281721933","create_time":"2018-10-29","description":"socket和ServerSocket的区别","id":"1540804424624","title":"socket和ServerSocket的区别","collection_name":"技术"},{"collection_id":"1540281721933","create_time":"2018-10-23","description":"spring beanfactory 实现","id":"1540200891257","title":"spring beanfactory 实现","collection_name":"技术"},{"collection_id":"1540374800080","create_time":"2018-10-23","description":"监听器,现在来说说Servlet的监听器Listener，它是实现了javax.servlet.ServletContextListener 接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。\n主要作用是： 做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。","id":"1540200822121","title":"监听器及springboot实现","collection_name":"spring"},{"collection_id":"1540374800080","create_time":"2018-10-23","description":"Servlet中的过滤器Filter是实现了javax.servlet.Filter接口的服务器端程序，主要的用途是过滤字符编码、做一些业务逻辑判断等。其工作原理是，只要你在web.xml文件配置好要拦截的客户端请求，它都会帮你拦截到请求，此时你就可以对请求或响应(Request、Response)统一设置编码，简化操作；同时还可进行逻辑判断，如用户是否已经登陆、有没有权限访问该页面等等工作。","id":"1540200642390","title":"过滤器及springboot实现","collection_name":"spring"}];var collection=[{"collection_id":"1540787832620","collection_name":"牛客网"},{"collection_id":"1540281721933","collection_name":"技术"},{"collection_id":"1540374800080","collection_name":"spring"}];